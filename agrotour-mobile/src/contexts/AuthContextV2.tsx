import React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { getSqliteDB } from '../services/SqliteDB';\nimport { api } from '../shared/api';\nimport { ENDPOINTS, STORAGE_KEYS } from '../shared/config';\n\nexport interface User {\n  id: string;\n  email: string;\n  nombre: string;\n  rol: 'cliente' | 'productor' | 'admin';\n  avatar_url?: string;\n}\n\nexport interface AuthContextType {\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n  login: (email: string, password: string) => Promise<void>;\n  logout: () => Promise<void>;\n  register: (data: any) => Promise<void>;\n  refreshToken: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load user from SqliteDB on mount\n  useEffect(() => {\n    loadAuthState();\n  }, []);\n\n  const loadAuthState = async () => {\n    try {\n      setIsLoading(true);\n      const db = getSqliteDB();\n\n      // Get stored auth tokens\n      // Assuming we stored user_id as a key, we'd need to get it from device_info or somewhere\n      // For now, we'll check if there are valid tokens\n      const devices = await db.getDeviceInfo();\n      if (devices) {\n        // Try to load user from some storage or just set authenticated state\n        setError(null);\n      }\n    } catch (err) {\n      console.error('[AuthContext] Error loading auth state:', err);\n      setError('Failed to load auth state');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const login = useCallback(async (email: string, password: string) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      // Call backend login endpoint\n      const response = await api.post<{ access: string; refresh: string; user: User }>(\n        ENDPOINTS.AUTH.LOGIN,\n        { email, password }\n      );\n\n      const { access, refresh, user: userData } = response;\n\n      // Save tokens to SqliteDB\n      const db = getSqliteDB();\n      const expiresAt = new Date(Date.now() + 60 * 60 * 1000).toISOString(); // 1 hora\n      await db.saveAuthTokens(userData.id, access, refresh, expiresAt);\n\n      // Save user\n      setUser(userData);\n\n      console.log('[AuthContext] Login successful');\n    } catch (err: any) {\n      console.error('[AuthContext] Login error:', err);\n      setError(err.message || 'Login failed');\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const logout = useCallback(async () => {\n    try {\n      setIsLoading(true);\n\n      const db = getSqliteDB();\n\n      if (user) {\n        // Call backend logout endpoint to blacklist token\n        try {\n          await api.post(ENDPOINTS.AUTH.LOGOUT, {});\n        } catch (err) {\n          console.warn('[AuthContext] Logout endpoint call failed (non-fatal)');\n        }\n\n        // Delete auth tokens from SqliteDB\n        await db.deleteAuthTokens(user.id);\n      }\n\n      setUser(null);\n      setError(null);\n      console.log('[AuthContext] Logout successful');\n    } catch (err) {\n      console.error('[AuthContext] Logout error:', err);\n      setError('Logout failed');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [user]);\n\n  const register = useCallback(async (data: any) => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      // Call backend register endpoint\n      const response = await api.post<{ access: string; refresh: string; user: User }>(\n        ENDPOINTS.AUTH.REGISTER,\n        data\n      );\n\n      const { access, refresh, user: userData } = response;\n\n      // Save tokens to SqliteDB\n      const db = getSqliteDB();\n      const expiresAt = new Date(Date.now() + 60 * 60 * 1000).toISOString();\n      await db.saveAuthTokens(userData.id, access, refresh, expiresAt);\n\n      setUser(userData);\n      console.log('[AuthContext] Registration successful');\n    } catch (err: any) {\n      console.error('[AuthContext] Register error:', err);\n      setError(err.message || 'Registration failed');\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const refreshToken = useCallback(async () => {\n    try {\n      if (!user) return;\n\n      const db = getSqliteDB();\n      const authData = await db.getAuthTokens(user.id);\n\n      if (!authData) {\n        throw new Error('No refresh token available');\n      }\n\n      // Call backend refresh endpoint\n      const response = await api.post<{ access: string }>(\n        ENDPOINTS.AUTH.REFRESH,\n        { refresh: authData.refresh_token }\n      );\n\n      // Update token in SqliteDB\n      const expiresAt = new Date(Date.now() + 60 * 60 * 1000).toISOString();\n      await db.saveAuthTokens(user.id, response.access, authData.refresh_token, expiresAt);\n\n      console.log('[AuthContext] Token refreshed');\n    } catch (err) {\n      console.error('[AuthContext] Token refresh failed:', err);\n      // If refresh fails, clear auth\n      if (user) {\n        await logout();\n      }\n    }\n  }, [user, logout]);\n\n  const value: AuthContextType = {\n    user,\n    isAuthenticated: !!user,\n    isLoading,\n    error,\n    login,\n    logout,\n    register,\n    refreshToken,\n  };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n