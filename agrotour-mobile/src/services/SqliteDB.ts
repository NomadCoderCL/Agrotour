import * as SQLite from 'expo-sqlite';\n\n/**\n * SqliteDB - Local relational database for mobile app\n * Replaces unstable AsyncStorage with robust SQLite backend\n * \n * Schema:\n * - sync_queue: offline operations (create/update/delete)\n * - product_cache: cached products from API\n * - cart_items: persistent shopping cart\n * - auth: JWT tokens (access + refresh)\n * - device_info: FCM token + device metadata\n */\n\nconst DB_NAME = 'agrotour_mobile.db';\nconst DB_VERSION = 1;\n\ninterface SyncOperation {\n  id: string;\n  op_json: string;  // JSON stringified operation\n  entity_type: string;  // 'product', 'order', 'cart'\n  status: 'pending' | 'synced' | 'failed';\n  retry_count: number;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface ProductCache {\n  id: string;\n  data_json: string;\n  updated_at: string;\n}\n\ninterface CartItem {\n  id: string;\n  product_id: string;\n  quantity: number;\n  data_json: string;  // cached product data\n  created_at: string;\n}\n\ninterface AuthToken {\n  user_id: string;\n  access_token: string;\n  refresh_token: string;\n  expires_at: string;\n}\n\ninterface DeviceInfo {\n  id: string;\n  fcm_token: string;\n  device_id: string;\n  platform: 'ios' | 'android';\n  last_sync: string;\n}\n\nclass SqliteDBService {\n  private db: SQLite.SQLiteDatabase | null = null;\n  private isInitialized = false;\n\n  async initialize(): Promise<void> {\n    try {\n      this.db = await SQLite.openDatabaseAsync(DB_NAME);\n      await this.runMigrations();\n      this.isInitialized = true;\n      console.log('[SqliteDB] Initialized successfully');\n    } catch (error) {\n      console.error('[SqliteDB] Initialization failed:', error);\n      throw error;\n    }\n  }\n\n  private async runMigrations(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    // Create sync_queue table\n    await this.db.execAsync(`\n      CREATE TABLE IF NOT EXISTS sync_queue (\n        id TEXT PRIMARY KEY,\n        op_json TEXT NOT NULL,\n        entity_type TEXT NOT NULL,\n        status TEXT DEFAULT 'pending',\n        retry_count INTEGER DEFAULT 0,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      );\n      CREATE INDEX IF NOT EXISTS idx_sync_queue_status ON sync_queue(status);\n      CREATE INDEX IF NOT EXISTS idx_sync_queue_entity ON sync_queue(entity_type);\n    `);\n\n    // Create product_cache table\n    await this.db.execAsync(`\n      CREATE TABLE IF NOT EXISTS product_cache (\n        id TEXT PRIMARY KEY,\n        data_json TEXT NOT NULL,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      );\n    `);\n\n    // Create cart_items table\n    await this.db.execAsync(`\n      CREATE TABLE IF NOT EXISTS cart_items (\n        id TEXT PRIMARY KEY,\n        product_id TEXT NOT NULL,\n        quantity INTEGER NOT NULL,\n        data_json TEXT NOT NULL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      );\n      CREATE INDEX IF NOT EXISTS idx_cart_product ON cart_items(product_id);\n    `);\n\n    // Create auth table\n    await this.db.execAsync(`\n      CREATE TABLE IF NOT EXISTS auth (\n        user_id TEXT PRIMARY KEY,\n        access_token TEXT NOT NULL,\n        refresh_token TEXT NOT NULL,\n        expires_at DATETIME NOT NULL\n      );\n    `);\n\n    // Create device_info table\n    await this.db.execAsync(`\n      CREATE TABLE IF NOT EXISTS device_info (\n        id TEXT PRIMARY KEY,\n        fcm_token TEXT,\n        device_id TEXT,\n        platform TEXT,\n        last_sync DATETIME\n      );\n    `);\n  }\n\n  /**\n   * SYNC QUEUE OPERATIONS\n   */\n  async addSyncOperation(op: Omit<SyncOperation, 'created_at' | 'updated_at'>): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `INSERT INTO sync_queue (id, op_json, entity_type, status, retry_count)\n       VALUES (?, ?, ?, ?, ?)`,\n      [op.id, op.op_json, op.entity_type, op.status, op.retry_count]\n    );\n  }\n\n  async getPendingSyncOperations(): Promise<SyncOperation[]> {\n    if (!this.db) throw new Error('Database not initialized');\n    const result = await this.db.getAllAsync<SyncOperation>(\n      `SELECT * FROM sync_queue WHERE status = 'pending' ORDER BY created_at ASC`\n    );\n    return result || [];\n  }\n\n  async updateSyncStatus(id: string, status: SyncOperation['status']): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `UPDATE sync_queue SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,\n      [status, id]\n    );\n  }\n\n  async incrementRetryCount(id: string): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `UPDATE sync_queue SET retry_count = retry_count + 1, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,\n      [id]\n    );\n  }\n\n  async deleteSyncOperation(id: string): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(`DELETE FROM sync_queue WHERE id = ?`, [id]);\n  }\n\n  /**\n   * PRODUCT CACHE OPERATIONS\n   */\n  async cacheProduct(product: { id: string; [key: string]: any }): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `INSERT OR REPLACE INTO product_cache (id, data_json, updated_at)\n       VALUES (?, ?, CURRENT_TIMESTAMP)`,\n      [product.id, JSON.stringify(product)]\n    );\n  }\n\n  async getCachedProduct(id: string): Promise<any | null> {\n    if (!this.db) throw new Error('Database not initialized');\n    const result = await this.db.getFirstAsync<ProductCache>(\n      `SELECT * FROM product_cache WHERE id = ?`,\n      [id]\n    );\n    return result ? JSON.parse(result.data_json) : null;\n  }\n\n  async getAllCachedProducts(): Promise<any[]> {\n    if (!this.db) throw new Error('Database not initialized');\n    const results = await this.db.getAllAsync<ProductCache>(\n      `SELECT * FROM product_cache`\n    );\n    return (results || []).map((r) => JSON.parse(r.data_json));\n  }\n\n  async clearProductCache(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(`DELETE FROM product_cache`);\n  }\n\n  /**\n   * CART OPERATIONS\n   */\n  async addCartItem(item: Omit<CartItem, 'created_at'>): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `INSERT OR REPLACE INTO cart_items (id, product_id, quantity, data_json)\n       VALUES (?, ?, ?, ?)`,\n      [item.id, item.product_id, item.quantity, item.data_json]\n    );\n  }\n\n  async getCartItems(): Promise<CartItem[]> {\n    if (!this.db) throw new Error('Database not initialized');\n    const results = await this.db.getAllAsync<CartItem>(`SELECT * FROM cart_items`);\n    return results || [];\n  }\n\n  async updateCartItemQuantity(id: string, quantity: number): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `UPDATE cart_items SET quantity = ? WHERE id = ?`,\n      [quantity, id]\n    );\n  }\n\n  async removeCartItem(id: string): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(`DELETE FROM cart_items WHERE id = ?`, [id]);\n  }\n\n  async clearCart(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(`DELETE FROM cart_items`);\n  }\n\n  /**\n   * AUTH OPERATIONS\n   */\n  async saveAuthTokens(userId: string, accessToken: string, refreshToken: string, expiresAt: string): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `INSERT OR REPLACE INTO auth (user_id, access_token, refresh_token, expires_at)\n       VALUES (?, ?, ?, ?)`,\n      [userId, accessToken, refreshToken, expiresAt]\n    );\n  }\n\n  async getAuthTokens(userId: string): Promise<AuthToken | null> {\n    if (!this.db) throw new Error('Database not initialized');\n    const result = await this.db.getFirstAsync<AuthToken>(\n      `SELECT * FROM auth WHERE user_id = ?`,\n      [userId]\n    );\n    return result || null;\n  }\n\n  async deleteAuthTokens(userId: string): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(`DELETE FROM auth WHERE user_id = ?`, [userId]);\n  }\n\n  /**\n   * DEVICE INFO OPERATIONS\n   */\n  async saveDeviceInfo(deviceId: string, fcmToken: string, platform: 'ios' | 'android'): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `INSERT OR REPLACE INTO device_info (id, fcm_token, device_id, platform, last_sync)\n       VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)`,\n      ['device_1', fcmToken, deviceId, platform]\n    );\n  }\n\n  async getDeviceInfo(): Promise<DeviceInfo | null> {\n    if (!this.db) throw new Error('Database not initialized');\n    const result = await this.db.getFirstAsync<DeviceInfo>(\n      `SELECT * FROM device_info WHERE id = 'device_1'`\n    );\n    return result || null;\n  }\n\n  async updateLastSync(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.runsAsync(\n      `UPDATE device_info SET last_sync = CURRENT_TIMESTAMP WHERE id = 'device_1'`\n    );\n  }\n\n  /**\n   * UTILITY OPERATIONS\n   */\n  async getStats(): Promise<{ syncQueue: number; productCache: number; cartItems: number }> {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const syncCount = await this.db.getFirstAsync<{ count: number }>(\n      `SELECT COUNT(*) as count FROM sync_queue WHERE status = 'pending'`\n    );\n    const prodCount = await this.db.getFirstAsync<{ count: number }>(\n      `SELECT COUNT(*) as count FROM product_cache`\n    );\n    const cartCount = await this.db.getFirstAsync<{ count: number }>(\n      `SELECT COUNT(*) as count FROM cart_items`\n    );\n\n    return {\n      syncQueue: syncCount?.count || 0,\n      productCache: prodCount?.count || 0,\n      cartItems: cartCount?.count || 0,\n    };\n  }\n\n  async wipeAllData(): Promise<void> {\n    if (!this.db) throw new Error('Database not initialized');\n    await this.db.execAsync(`\n      DELETE FROM sync_queue;\n      DELETE FROM product_cache;\n      DELETE FROM cart_items;\n      DELETE FROM auth;\n      DELETE FROM device_info;\n    `);\n  }\n}\n\n// Singleton instance\nlet instance: SqliteDBService | null = null;\n\nexport async function initializeSqliteDB(): Promise<SqliteDBService> {\n  if (!instance) {\n    instance = new SqliteDBService();\n    await instance.initialize();\n  }\n  return instance;\n}\n\nexport function getSqliteDB(): SqliteDBService {\n  if (!instance) {\n    throw new Error('SqliteDB not initialized. Call initializeSqliteDB() first.');\n  }\n  return instance;\n}\n\nexport { SqliteDBService };\n